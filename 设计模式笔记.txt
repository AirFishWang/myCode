学习设计模式所需要思考的问题：
    （1）为什么要这么设计，这么设计能够解决哪些问题
    （2）这么设计，还存在哪些方面的不足

设计模式的常见7种原则
    （1）单一职责原则:  一个类只负责一个功能领域中的相应职责 
    （2）开闭原则:      软件实体应对扩展开放，而对修改关闭
    （3）里氏代换原则:  所有引用基类对象的地方能够透明地使用其子类的对象
    （4）依赖倒转原则:  抽象不应该依赖于细节，细节应该依赖于抽象(即应该面向接口编程，而不是针对实现编程)
    （5）接口隔离原则:  使用多个专门的接口，而不使用单一的总接口
    （6）合成复用原则:  尽量使用对象组合，而不是继承来达到复用的目的(区分Is-a和Has-a的关系)
    （7）迪米特法则；   一个软件实体应当尽可能少地与其他实体发生相互作用
    博客地址: http://blog.csdn.net/lovelion/article/details/17517213
    
    
1. 简单工厂模式
    将对象的创建与使用分离，防止在客户程序中大量创建对象的代码冗余(例如代码中多处需要依据type创建各种不同的对象，很多if-else)
    缺点: 
    （1）当类比较多的时候，简单工厂类就会显得冗长
    （2）当扩展新的类别的时候，必须修改简单工厂类的代码，违背了开闭原则
2. 工厂方法模式
    声明一个抽象的工作基类，针对每一个产品类，对应的声明一个工厂类(并继承工厂基类)，客户程序根据需要new出不同的工厂，并通过该工厂创建产品对象。
    当需要扩展新的产品类别的时候，只需要添加新的工厂类并继承工厂基类，而不需要修改原来的代码，克服了简单工厂模式的第二个缺点。
    缺点: 每一个类都对应一个工厂，增加了系统的复杂度
3. 抽象工厂模式:
    将具有相同特点的工厂类抽象出来，由子类具体实现
    
4. 单例模式
    确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。
    http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/ 
    
5. 原型模式
    用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象
    工作原理：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程
    注意深拷贝和浅拷贝的问题，如果需要深拷贝则需要通过java的序列化来实现
    
6. 建造者模式
    创建复杂的组合对象
    
7. 适配器模式
    将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。
    应用场景举例: 系统A声明了一个函数接口sort用于排序，现在手头有一个无源代码的算法库dll，其中的排序函数接口是quickSort，如果在不修改现有代码下，使系统能够使用算法库的排序函数

8. 桥接模式           
    处理多维度变化，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。
   事例: 毛笔和蜡笔。假如我们需要大中小3种型号的画笔，能够绘制12种不同的颜色，如果使用蜡笔，需要准备3×12 = 36支，但如果使用毛笔的话，只需要提供3种型号的毛笔，外加12个颜料盒即可，涉及到的对象个数仅为 3 + 12 = 15，远小于36，却能实现与36支蜡笔同样的功能。如果增加一种新型号的画笔，并且也需要具有12种颜色，对应的蜡笔需增加12支，而毛笔只需增加一支。
   
   
    
    
    
    
    
    